#include "stdint.h"
#include "stdbool.h"

#include "HalUart.h"
#include "HalInterrupt.h"
#include "HalTimer.h"
#include "Uart.h"

#include "stdio.h"
#include "stdlib.h"

#include "Kernel.h"
#include "armcpu.h"

#define ENABLE_LCD 1

#if ENABLE_LCD
// Simple CLCD/PL110 register mapping for RealView PB-A8 (QEMU)
#define LCD_BASE        0x10020000
#define LCD_TIM0        (*(volatile uint32_t*)(LCD_BASE + 0x00))
#define LCD_TIM1        (*(volatile uint32_t*)(LCD_BASE + 0x04))
#define LCD_TIM2        (*(volatile uint32_t*)(LCD_BASE + 0x08))
#define LCD_TIM3        (*(volatile uint32_t*)(LCD_BASE + 0x0C))
#define LCD_UPBASE      (*(volatile uint32_t*)(LCD_BASE + 0x10))
#define LCD_CONTROL     (*(volatile uint32_t*)(LCD_BASE + 0x18))
#define LCD_IMSC        (*(volatile uint32_t*)(LCD_BASE + 0x1C))

#define LCD_WIDTH       640
#define LCD_HEIGHT      480

// 16bpp RGB565 framebuffer; aligned for the controller, placed in .fb (see linker)
static uint16_t lcd_framebuffer[LCD_HEIGHT][LCD_WIDTH] __attribute__((aligned(16), section(".fb")));

// 8x8 bitmap font (ASCII 32-127)
static const uint8_t font8x8_basic[96][8] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //  
    {0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00}, // !
    {0x6C,0x6C,0x24,0x00,0x00,0x00,0x00,0x00}, // "
    {0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00}, // #
    {0x18,0x7E,0xC0,0x7C,0x06,0xFC,0x18,0x00}, // $
    {0x00,0xC6,0xCC,0x18,0x30,0x66,0xC6,0x00}, // %
    {0x38,0x6C,0x38,0x76,0xDC,0xCC,0x76,0x00}, // &
    {0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00}, // '
    {0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00}, // (
    {0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00}, // )
    {0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00}, // *
    {0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00}, // +
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30}, // ,
    {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00}, // -
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00}, // .
    {0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00}, // /
    {0x7C,0xC6,0xCE,0xD6,0xE6,0xC6,0x7C,0x00}, // 0
    {0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00}, // 1
    {0x7C,0xC6,0x06,0x1C,0x30,0x66,0xFE,0x00}, // 2
    {0x7C,0xC6,0x06,0x3C,0x06,0xC6,0x7C,0x00}, // 3
    {0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x1E,0x00}, // 4
    {0xFE,0xC0,0xC0,0xFC,0x06,0xC6,0x7C,0x00}, // 5
    {0x3C,0x60,0xC0,0xFC,0xC6,0xC6,0x7C,0x00}, // 6
    {0xFE,0xC6,0x0C,0x18,0x30,0x30,0x30,0x00}, // 7
    {0x7C,0xC6,0xC6,0x7C,0xC6,0xC6,0x7C,0x00}, // 8
    {0x7C,0xC6,0xC6,0x7E,0x06,0x0C,0x78,0x00}, // 9
    {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00}, // :
    {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30}, // ;
    {0x0E,0x1C,0x38,0x70,0x38,0x1C,0x0E,0x00}, // <
    {0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00}, // =
    {0x70,0x38,0x1C,0x0E,0x1C,0x38,0x70,0x00}, // >
    {0x7C,0xC6,0x0E,0x1C,0x18,0x00,0x18,0x00}, // ?
    {0x7C,0xC6,0xDE,0xDE,0xDE,0xC0,0x78,0x00}, // @
    {0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0x00}, // A
    {0xFC,0x66,0x66,0x7C,0x66,0x66,0xFC,0x00}, // B
    {0x3C,0x66,0xC0,0xC0,0xC0,0x66,0x3C,0x00}, // C
    {0xF8,0x6C,0x66,0x66,0x66,0x6C,0xF8,0x00}, // D
    {0xFE,0x62,0x68,0x78,0x68,0x62,0xFE,0x00}, // E
    {0xFE,0x62,0x68,0x78,0x68,0x60,0xF0,0x00}, // F
    {0x3C,0x66,0xC0,0xC0,0xCE,0x66,0x3E,0x00}, // G
    {0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00}, // H
    {0x7E,0x18,0x18,0x18,0x18,0x18,0x7E,0x00}, // I
    {0x1E,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00}, // J
    {0xE6,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00}, // K
    {0xF0,0x60,0x60,0x60,0x62,0x66,0xFE,0x00}, // L
    {0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0x00}, // M
    {0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00}, // N
    {0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00}, // O
    {0xFC,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00}, // P
    {0x7C,0xC6,0xC6,0xC6,0xD6,0xCC,0x7A,0x00}, // Q
    {0xFC,0x66,0x66,0x7C,0x6C,0x66,0xE6,0x00}, // R
    {0x7C,0xC6,0x60,0x38,0x0C,0xC6,0x7C,0x00}, // S
    {0x7E,0x7E,0x5A,0x18,0x18,0x18,0x3C,0x00}, // T
    {0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00}, // U
    {0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00}, // V
    {0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0x00}, // W
    {0xC6,0xC6,0x6C,0x38,0x6C,0xC6,0xC6,0x00}, // X
    {0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00}, // Y
    {0xFE,0xC6,0x8C,0x18,0x32,0x66,0xFE,0x00}, // Z
    {0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00}, // [
    {0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00}, // backslash
    {0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00}, // ]
    {0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00}, // ^
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF}, // _
    {0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00}, // `
    {0x00,0x00,0x78,0x0C,0x7C,0xCC,0x76,0x00}, // a
    {0xE0,0x60,0x60,0x7C,0x66,0x66,0xDC,0x00}, // b
    {0x00,0x00,0x7C,0xC6,0xC0,0xC6,0x7C,0x00}, // c
    {0x1C,0x0C,0x0C,0x7C,0xCC,0xCC,0x76,0x00}, // d
    {0x00,0x00,0x7C,0xC6,0xFE,0xC0,0x7C,0x00}, // e
    {0x1C,0x36,0x30,0x78,0x30,0x30,0x78,0x00}, // f
    {0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0xF8}, // g
    {0xE0,0x60,0x6C,0x76,0x66,0x66,0xE6,0x00}, // h
    {0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00}, // i
    {0x06,0x00,0x06,0x06,0x06,0x66,0x66,0x3C}, // j
    {0xE0,0x60,0x66,0x6C,0x78,0x6C,0xE6,0x00}, // k
    {0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // l
    {0x00,0x00,0xEC,0xFE,0xD6,0xC6,0xC6,0x00}, // m
    {0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x00}, // n
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0x00}, // o
    {0x00,0x00,0xDC,0x66,0x66,0x7C,0x60,0xF0}, // p
    {0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0x1E}, // q
    {0x00,0x00,0xDC,0x76,0x66,0x60,0xF0,0x00}, // r
    {0x00,0x00,0x7E,0xC0,0x7C,0x06,0xFC,0x00}, // s
    {0x10,0x30,0x7C,0x30,0x30,0x36,0x1C,0x00}, // t
    {0x00,0x00,0xCC,0xCC,0xCC,0xCC,0x76,0x00}, // u
    {0x00,0x00,0xC6,0xC6,0xC6,0x6C,0x38,0x00}, // v
    {0x00,0x00,0xC6,0xD6,0xFE,0xFE,0x6C,0x00}, // w
    {0x00,0x00,0xC6,0x6C,0x38,0x6C,0xC6,0x00}, // x
    {0x00,0x00,0xC6,0xC6,0xC6,0x7E,0x06,0xFC}, // y
    {0x00,0x00,0xFE,0x8C,0x18,0x32,0xFE,0x00}, // z
    {0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00}, // {
    {0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00}, // |
    {0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00}, // }
    {0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00}, // ~
};

static uint32_t lcd_console_row = 0;
static uint32_t lcd_console_col = 0;
#define LCD_CONSOLE_COLS (LCD_WIDTH / 8)
#define LCD_CONSOLE_ROWS (LCD_HEIGHT / 8)
#endif

static void Hw_init(void);
static void Kernel_init(void);
#if ENABLE_LCD
static void Lcd_init(void);
static void Lcd_console_init(void);
void Lcd_console_putc(char ch);
#endif

static void Printf_test(void);
static void Timer_test(void);

static void Test_critical_section(uint32_t p, uint32_t taskId);

void User_task0(void);
void User_task1(void);
void User_task2(void);

extern volatile PL011_t* Uart;

#if ENABLE_LCD
static void Lcd_init(void)
{
    // Disable while configuring
    LCD_CONTROL = 0;

    // Timing values for 640x480 @ ~25MHz (PL110 on RealView/QEMU)
    LCD_TIM0 = 0x3F1F3F9C;
    LCD_TIM1 = 0x080B61DF;
    LCD_TIM2 = 0x067F1800;
    LCD_TIM3 = 0x00000000;

    // Mask all LCD interrupts
    LCD_IMSC = 0;

    // Set framebuffer base
    LCD_UPBASE = (uint32_t)lcd_framebuffer;

    // Enable LCD, set 16bpp (RGB565), TFT mode, BGR order, and power on
    LCD_CONTROL = (1 << 0)       // LCD enable
                | (6 << 1)       // 16bpp 5:6:5
                | (1 << 5)       // TFT panel
                | (1 << 8)       // BGR
                | (1 << 11);     // LCD power enable
}

static void Lcd_console_init(void)
{
    // clear screen to black
    for (uint32_t y = 0; y < LCD_HEIGHT; y++)
    {
        for (uint32_t x = 0; x < LCD_WIDTH; x++)
        {
            lcd_framebuffer[y][x] = 0x0000;
        }
    }
    lcd_console_row = 0;
    lcd_console_col = 0;
}

static void Lcd_draw_char(uint32_t row, uint32_t col, char ch)
{
    if (ch < 32 || ch > 127)
    {
        ch = '?';
    }
    const uint8_t* glyph = font8x8_basic[ch - 32];

    uint32_t base_x = col * 8;
    uint32_t base_y = row * 8;
    for (uint32_t dy = 0; dy < 8; dy++)
    {
        uint8_t bits = glyph[dy];
        for (uint32_t dx = 0; dx < 8; dx++)
        {
            uint16_t color = (bits & (1 << (7 - dx))) ? 0xFFFF : 0x0000;
            lcd_framebuffer[base_y + dy][base_x + dx] = color;
        }
    }
}

static void Lcd_copy_up(uint32_t lines)
{
    // Move framebuffer up by 'lines' lines (each line = LCD_WIDTH pixels)
    // Safe because destination is below source.
    uint32_t total_pixels = (LCD_HEIGHT - lines) * LCD_WIDTH;
    for (uint32_t i = 0; i < total_pixels; i++)
    {
        lcd_framebuffer[0][i] = lcd_framebuffer[lines][i];
    }
}

static void Lcd_scroll(void)
{
    if (lcd_console_row < LCD_CONSOLE_ROWS)
    {
        return;
    }

    // move lines up by one character height (8px)
    Lcd_copy_up(8);
    // clear last 8-pixel rows
    for (uint32_t y = LCD_HEIGHT - 8; y < LCD_HEIGHT; y++)
    {
        for (uint32_t x = 0; x < LCD_WIDTH; x++)
        {
            lcd_framebuffer[y][x] = 0x0000;
        }
    }
    lcd_console_row = LCD_CONSOLE_ROWS - 1;
}

void Lcd_console_putc(char ch)
{
    if (ch == '\n')
    {
        lcd_console_col = 0;
        lcd_console_row++;
        Lcd_scroll();
        return;
    }
    if (ch == '\r')
    {
        lcd_console_col = 0;
        return;
    }

    Lcd_draw_char(lcd_console_row, lcd_console_col, ch);
    lcd_console_col++;
    if (lcd_console_col >= LCD_CONSOLE_COLS)
    {
        lcd_console_col = 0;
        lcd_console_row++;
        Lcd_scroll();
    }
}
#endif

static void Handle_shutdown(void)
{
    debug_printf("Shutdown requested. Halting...\n");
    disable_irq();
    while(true);
}

void main(void)
{
    Hw_init();

    uint32_t i = 100;
    while(i--)
    {
        Hal_uart_put_char('N');
    }
    Hal_uart_put_char('\n');

    putstr("Hello World!\n");

    Printf_test();
    Timer_test();

    Kernel_init();

    while(true);
}

static void Hw_init(void)
{
    Hal_interrupt_init();
    Hal_uart_init();
    Hal_timer_init();
#if ENABLE_LCD
    Lcd_init();
    Lcd_console_init();
#endif
}


static void Kernel_init(void)
{
    uint32_t taskId;

    Kernel_task_init();
    Kernel_event_flag_init();
    Kernel_msgQ_init();
    Kernel_sem_init(1);
    Kernel_mutex_init();

    taskId = Kernel_task_create(User_task0);
    if (NOT_ENOUGH_TASK_NUM == taskId)
    {
        putstr("Task0 creation fail\n");
    }

    taskId = Kernel_task_create(User_task1);
    if (NOT_ENOUGH_TASK_NUM == taskId)
    {
        putstr("Task1 creation fail\n");
    }

    taskId = Kernel_task_create(User_task2);
    if (NOT_ENOUGH_TASK_NUM == taskId)
    {
        putstr("Task2 creation fail\n");
    }

    Kernel_start();
}

static void Printf_test(void)
{
    char* str = "printf pointer test";
    char* nullptr = 0;
    uint32_t i = 5;
    uint32_t* sysctrl0 = (uint32_t*)0x10001000;

    debug_printf("%s\n", "Hello printf");
    debug_printf("output string pointer: %s\n", str);
    debug_printf("%s is null pointer, %u number\n", nullptr, 10);
    debug_printf("%u = 5\n", i);
    debug_printf("dec=%u hex=%x\n", 0xff, 0xff);
    debug_printf("print zero %u\n", 0);
    debug_printf("SYSCTRL0 %x\n", *sysctrl0);
}

static void Timer_test(void)
{
    for(uint32_t i = 0; i < 5 ; i++)
    {
        debug_printf("current count : %u\n", Hal_timer_get_1ms_counter());
        delay(1000);
    }
}

void User_task0(void)
{
    uint32_t local = 0;
    debug_printf("User Task #0 SP=0x%x\n", &local);

    uint8_t  cmdBuf[16];
    uint32_t cmdBufIdx = 0;
    uint8_t  uartch = 0;

    while(true)
    {
        // Poll UART in case interrupt delivery is lost
        if (Uart->uartfr.bits.RXFE == 0)
        {
            uint8_t ch = Hal_uart_get_char();

            if (ch == 'Q' || ch == 'q')
            {
                Kernel_send_events(KernelEventFlag_Shutdown);
            }
            else if (ch == 'U' || ch == 'u')
            {
                Kernel_send_events(KernelEventFlag_Unlock);
                Hal_uart_put_char(ch);
                debug_printf("[UART POLL] unlock key '%c'\n", ch);
                Kernel_yield();
                continue;
            }
            else if (ch == 'X' || ch == 'x')
            {
                Kernel_send_events(KernelEventFlag_CmdOut);
                Hal_uart_put_char(ch);
                debug_printf("[UART POLL] cmd key '%c'\n", ch);
                Kernel_yield();
                continue;
            }
            else
            {
                Hal_uart_put_char(ch);
                debug_printf("[UART POLL] char '%c'\n", ch);
                Kernel_send_msg(KernelMsgQ_Task0, &ch, 1);
                Kernel_send_events(KernelEventFlag_UartIn);
                Kernel_yield();
                continue;
            }
        }

        KernelEventFlag_t handle_event = Kernel_wait_events(KernelEventFlag_UartIn|KernelEventFlag_CmdOut|KernelEventFlag_Shutdown|KernelEventFlag_Tick);
        switch(handle_event)
        {
        case KernelEventFlag_UartIn:
            Kernel_recv_msg(KernelMsgQ_Task0, &uartch, 1);
            if (uartch == '\r')
            {
                cmdBuf[cmdBufIdx] = '\0';

                Kernel_send_msg(KernelMsgQ_Task1, &cmdBufIdx, 1);
                Kernel_send_msg(KernelMsgQ_Task1, cmdBuf, cmdBufIdx);
                Kernel_send_events(KernelEventFlag_CmdIn);

                cmdBufIdx = 0;
            }
            else
            {
                cmdBuf[cmdBufIdx] = uartch;
                cmdBufIdx++;
                cmdBufIdx %= 16;
            }
            break;
        case KernelEventFlag_CmdOut:
            //debug_printf("\nCmdOut Event by Task0\n");
            Test_critical_section(5, 0);
            break;
        case KernelEventFlag_Shutdown:
            Handle_shutdown();
            break;
        case KernelEventFlag_Tick:
            // periodic tick: no-op, just yield
            break;
        }
        Kernel_yield();
    }
}

void User_task1(void)
{
    uint32_t local = 0;

    debug_printf("User Task #1 SP=0x%x\n", &local);

    uint8_t cmdlen = 0;
    uint8_t cmd[16] = {0};

    while(true)
    {
        KernelEventFlag_t handle_event = Kernel_wait_events(KernelEventFlag_CmdIn|KernelEventFlag_Unlock|KernelEventFlag_Tick);
        switch(handle_event)
        {
        case KernelEventFlag_CmdIn:
            memclr(cmd, 16);
            Kernel_recv_msg(KernelMsgQ_Task1, &cmdlen, 1);
            Kernel_recv_msg(KernelMsgQ_Task1, cmd, cmdlen);
            debug_printf("\nRecv Cmd: %s\n", cmd);
            break;
        case KernelEventFlag_Unlock:

            break;
        case KernelEventFlag_Tick:
            // periodic tick: no-op, just yield
            break;
        }
        Kernel_yield();
    }
}

void User_task2(void)
{
    uint32_t local = 0;

    debug_printf("User Task #2 SP=0x%x\n", &local);

    while(true)
    {
        // Throttle output so other tasks/logs can run
        Kernel_wait_events(KernelEventFlag_Tick);
        Test_critical_section(3, 2);
        Kernel_yield();
    }
}

static uint32_t shared_value;
static void Test_critical_section(uint32_t p, uint32_t taskId)
{
    Kernel_lock_mutex();

    debug_printf("User Task #%u Send=%u\n", taskId, p);
    shared_value = p;
    Kernel_yield();
    delay(1000);
    debug_printf("User Task #%u Shared Value=%u\n", taskId, shared_value);

    Kernel_unlock_mutex();
}
